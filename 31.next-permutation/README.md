# 31. 下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

 

## 示例 1：
```
输入：nums = [1,2,3]
输出：[1,3,2]
```

## 示例 2：
```
输入：nums = [3,2,1]
输出：[1,2,3]
```

## 示例 3：
```
输入：nums = [1,1,5]
输出：[1,5,1]
```

## 示例 4：
```
输入：nums = [1]
输出：[1]
```

## 提示：

+ 1 <= nums.length <= 100
+ 0 <= nums[i] <= 100

## 解题思路
1. 先找出最大的索引 k 满足 nums[k] < nums[k+1]，如果不存在，就翻转整个数组；
2. 再找出另一个最大索引 l 满足 nums[l] > nums[k]；
3. 交换 nums[l] 和 nums[k]；
4. 最后翻转 nums[k+1:]。

### 举个例子：

比如 nums = [1,2,7,4,3,1]，下一个排列是什么？

我们找到第一个最大索引是 nums[1] = 2

再找到第二个最大索引是 nums[4] = 3

交换，nums = [1,3,7,4,2,1];

翻转，nums = [1,3,1,2,4,7]

完毕!
